# Cursor Rules for Angular Admin Template

## Component Development Guidelines

### When creating or modifying components:

1. **Always use existing component patterns** - Before creating new components, check if similar functionality exists in `src/app/shared/components/` and reuse or extend existing components.

2. **Follow shadcn/ui architecture** - All components must follow the shadcn/ui design system patterns:
   - Use `class-variance-authority` (cva) for variant management
   - Use Tailwind CSS for styling
   - Follow accessibility best practices
   - Use Angular signals for reactivity

3. **Component Structure Requirements**:
   - **Standalone components**: All components must be standalone Angular components
   - **Naming convention**: 
     - Component class: `Zard[ComponentName]Component`
     - Selector: `z-[component-name]` (kebab-case)
     - Export as: `z[ComponentName]` (camelCase)
   - **File structure**: Each component should have:
     - `[component-name].component.ts` - Main component file
     - `[component-name].variants.ts` - Variant definitions using cva
     - Optional: `[component-name].module.ts` if module is needed

4. **Required Component Patterns**:
   ```typescript
   - Use `input()` signals for all inputs (not @Input())
   - Use `computed()` signals for derived state
   - Use `mergeClasses()` from `@shared/utils/merge-classes` for class merging
   - Use `ViewEncapsulation.None`
   - Use `ChangeDetectionStrategy.OnPush`
   - Variants must use `cva()` from 'class-variance-authority'
   - Export variant types using `VariantProps<typeof variantFunction>`
   ```

5. **Class Management**:
   - Always use `mergeClasses()` utility instead of direct class concatenation
   - Use `ClassValue` type from 'clsx' for class inputs
   - Variant props should be prefixed with `z` (e.g., `zType`, `zSize`, `zShape`)
   - Support custom classes via `class` input

6. **Component Variants Pattern**:
   ```typescript
   // In [component].variants.ts
   import { cva, VariantProps } from 'class-variance-authority';
   
   export const componentVariants = cva(
     "base-classes-here",
     {
       variants: {
         zType: { default: '', variant1: '...', variant2: '...' },
         zSize: { default: '...', sm: '...', lg: '...' },
       },
       defaultVariants: { zType: 'default', zSize: 'default' }
     }
   );
   export type ZardComponentVariants = VariantProps<typeof componentVariants>;
   ```

7. **Component Implementation Pattern**:
   ```typescript
   @Component({
     selector: 'z-component-name',
     exportAs: 'zComponentName',
     standalone: true,
     imports: [/* required imports */],
     changeDetection: ChangeDetectionStrategy.OnPush,
     encapsulation: ViewEncapsulation.None,
     // template or templateUrl
     host: {
       '[class]': 'classes()',
     },
   })
   export class ZardComponentNameComponent {
     readonly zType = input<ZardComponentVariants['zType']>('default');
     readonly class = input<ClassValue>('');
     
     protected readonly classes = computed(() =>
       mergeClasses(
         componentVariants({ zType: this.zType() }),
         this.class(),
       ),
     );
   }
   ```

8. **Reuse Existing Components**:
   - When user requests functionality, first check if existing components can be used or extended
   - Prefer composition over creating new components from scratch
   - Use existing components like `ZardButtonComponent`, `ZardIconComponent`, etc. within new components

9. **Path Aliases**:
   - Use `@shared/components` for component imports
   - Use `@shared/utils` for utility imports
   - Defined in `tsconfig.json` and `components.json`

10. **Accessibility**:
    - Include proper ARIA attributes
    - Use semantic HTML
    - Support keyboard navigation
    - Follow WCAG guidelines

11. **Styling**:
    - Use Tailwind CSS utility classes
    - Support dark mode via `dark:` prefix
    - Use CSS variables for theming (defined in `src/styles.css`)
    - Follow shadcn/ui design tokens

12. **When adding new features**:
    - Check existing components first
    - Extend existing components when possible
    - Maintain consistency with existing patterns
    - Ensure all variants are properly typed
    - Add proper TypeScript types

13. **Layout Component Usage** - **MANDATORY for all page/route components**:
    - **ALWAYS** wrap page components (route components) with the layout component structure
    - Use `LayoutComponent` from `@shared/components/layout/layout.component`
    - Import `LayoutModule` or individual layout components as needed
    - Standard layout structure:
      ```typescript
      @Component({
        selector: 'app-page-name',
        standalone: true,
        imports: [LayoutComponent, HeaderComponent, SidebarComponent, ContentComponent, FooterComponent],
        templateUrl: './page-name.component.html',
      })
      ```
    - **Minimum required**: At least use `<z-layout><z-content>...</z-content></z-layout>` for all page components
    - Layout components available:
      - `z-layout` - Main layout wrapper (required)
      - `z-header` - Header section (optional but recommended)
      - `z-sidebar` - Sidebar navigation (optional)
      - `z-content` - Main content area (required)
      - `z-footer` - Footer section (optional)
    - **NEVER** create page components without using the layout structure
    - Layout automatically handles responsive behavior and direction (horizontal/vertical)

14. **Template File Separation** - **MANDATORY for all components**:
    - **ALWAYS** separate HTML templates from TypeScript component files
    - **NEVER** use inline `template` property in `@Component` decorator
    - **ALWAYS** use `templateUrl` property pointing to a separate `.html` file
    - File naming convention:
      - Component file: `[component-name].component.ts`
      - Template file: `[component-name].component.html` (in the same directory)
    - Example:
      ```typescript
      @Component({
        selector: 'app-component-name',
        standalone: true,
        templateUrl: './component-name.component.html',  // ✅ CORRECT
        // template: `...`  // ❌ NEVER use inline templates
      })
      ```
    - **Exception**: Only very small utility components with minimal HTML (1-2 lines) may use inline templates, but this should be rare
    - This separation improves:
      - Code readability and maintainability
      - Better IDE support and syntax highlighting
      - Easier collaboration between developers
      - Better separation of concerns

15. **Form Validation Pattern** - **MANDATORY for all forms with validation**:
    - **ALWAYS** implement form validation using the following pattern:
    
    **TypeScript Component Pattern**:
    ```typescript
    export class FormComponent {
      // Form data using signals
      formData = {
        fieldName: signal(''),
        // ... other fields
      };

      // Form validation state
      formSubmitted = signal(false);

      // Computed signal to check if form is valid
      readonly isFormValid = computed(() => {
        return this.formData.fieldName() && this.formData.fieldName().trim() !== '';
        // Add all required field validations
      });

      // Computed signals for error messages (one per field)
      readonly fieldNameError = computed(() => {
        if (!this.formSubmitted()) return '';
        const value = this.formData.fieldName();
        if (!value || value.trim() === '') {
          return 'Field name is required';
        }
        // Add other validation rules
        return '';
      });

      // Computed signals to check if field has error (for styling)
      readonly fieldNameHasError = computed(() => {
        return this.formSubmitted() && (!this.formData.fieldName() || this.formData.fieldName().trim() === '');
      });

      // Submit handler
      onSubmit(): void {
        // Mark form as submitted to show validation errors
        this.formSubmitted.set(true);

        // Guard: prevent execution if form is invalid
        if (!this.isFormValid()) {
          return;
        }

        // Proceed with form submission
        // ...
        
        // Reset formSubmitted on successful submission
        // this.formSubmitted.set(false);
      }
    }
    ```

    **HTML Template Pattern**:
    ```html
    <z-form-field>
      <z-form-label zRequired>Field Name</z-form-label>
      <z-form-control [errorMessage]="fieldNameError()">
        <z-input-group [zPrefix]="iconTemplate">
          <input 
            z-input 
            type="text" 
            [ngModel]="formData.fieldName()" 
            (ngModelChange)="formData.fieldName.set($event)" 
            name="fieldName" 
            placeholder="Enter field name" 
            [zStatus]="fieldNameHasError() ? 'error' : undefined" 
            class="w-full" 
          />
        </z-input-group>
      </z-form-control>
    </z-form-field>

    <!-- Submit Button -->
    <z-button 
      [zType]="isSaving() || !isFormValid() ? 'ghost' : 'default'" 
      [disabled]="isSaving()" 
      (click)="!isSaving() && onSubmit()"
    >
      Save
    </z-button>
    ```

    **Key Requirements**:
    - ✅ **ALWAYS** use `formSubmitted` signal to track when form has been submitted
    - ✅ **ALWAYS** create computed signals for error messages (`fieldNameError`)
    - ✅ **ALWAYS** create computed signals for error state (`fieldNameHasError`) for styling
    - ✅ **ALWAYS** set `formSubmitted.set(true)` at the start of submit handler
    - ✅ **ALWAYS** use `[errorMessage]` binding on `z-form-control` to display errors
    - ✅ **ALWAYS** use `[zStatus]="fieldHasError() ? 'error' : undefined"` on inputs to show red border
    - ✅ **ALWAYS** disable button only when saving (`[disabled]="isSaving()"`), NOT when invalid
    - ✅ **ALWAYS** allow button click even when invalid to trigger validation
    - ✅ **ALWAYS** use button type `ghost` when invalid/saving, `default` when valid
    - ✅ **ALWAYS** reset `formSubmitted.set(false)` on successful submission
    - ✅ **ALWAYS** validate required fields (check for empty/whitespace)
    - ✅ **ALWAYS** use `zRequired` on form labels for required fields

    **Validation Rules**:
    - Required fields: Check if value exists and is not empty/whitespace
    - Email fields: Add email format validation
    - Phone fields: Add phone format validation
    - Min/Max length: Add length validations
    - Custom validations: Add business rule validations

    **Error Display**:
    - Error messages appear below the input field automatically via `z-form-control`
    - Red border on input via `zStatus="error"`
    - Error message text is red (`text-red-500` via form control component)

    **Button State Management**:
    - Button is `ghost` type when: form is invalid OR saving
    - Button is `default` type when: form is valid AND not saving
    - Button is disabled only when: saving (NOT when invalid - allows validation trigger)
    - Button click handler: Always call submit handler, validation guard prevents execution

## Copying from Front Projects - **CRITICAL RULE**

**Important**: The front app is located in the `old project/front/` folder at the root of the workspace.

When the user says "copy from front project" or similar instructions:

1. **NEVER copy the design/UI/styling** - The design must always maintain the admintemplate design system
2. **ALWAYS use existing shared components** - Use components from `src/app/shared/components/` instead of copying UI elements
3. **ONLY adapt logic and services** - Extract and adapt:
   - Business logic and functionality
   - Service calls and API integrations
   - Data models and interfaces
   - Component behavior and state management
4. **Maintain admintemplate patterns**:
   - Use existing `Zard*` components for UI elements
   - Follow the component structure and naming conventions
   - Use existing layout components (`z-layout`, `z-content`, etc.)
   - Apply admintemplate styling and variants
5. **Service adaptation**:
   - Adapt service calls to match existing service patterns in `src/app/shared/services/`
   - Use existing API service structure
   - Maintain consistency with existing interceptors and guards
6. **What to copy**:
   - ✅ Logic and functionality
   - ✅ Service methods and API calls (adapted to project structure)
   - ✅ Data models (adapted to project naming)
   - ✅ Business rules and validations
7. **What NOT to copy**:
   - ❌ HTML templates and UI structure
   - ❌ CSS classes and styling
   - ❌ Component design and layout
   - ❌ Visual elements and UI components

8. **Creating missing components**:
   - If a component/design doesn't exist in `src/app/shared/components/`, **CREATE IT** using admintemplate's design system
   - **NEVER** copy the front project's design - build it from scratch using:
     - Existing `Zard*` shared components as building blocks
     - Admintemplate styling patterns and variants
     - shadcn/ui design principles
     - Tailwind CSS utility classes from the project
   - Compose new components using existing shared components (buttons, cards, inputs, etc.)
   - Follow all component development guidelines (standalone, signals, cva variants, etc.)
   - The new component should look and feel like it belongs in admintemplate, not the front project

**Summary**: When copying from another project, extract the logic and adapt it to use admintemplate's design system and shared components. Never bring over the visual design. If a component doesn't exist, create it using admintemplate's patterns and shared components, not the front project's design.

## Important Notes

- **NEVER** create components that duplicate existing functionality
- **ALWAYS** check `src/app/shared/components/` before creating new components
- **ALWAYS** use the existing utility functions (`mergeClasses`, `cn`, `transform`, `generateId`)
- **ALWAYS** follow the exact naming conventions and patterns shown above
- **ALWAYS** make components standalone and use signals for inputs
- **ALWAYS** use `cva` for variant management, never manual class strings
- **ALWAYS** use `z-layout` with `z-content` (at minimum) for all page/route components
- **NEVER** create page components without the layout structure - it's mandatory for consistency
- **ALWAYS** separate HTML templates into `.html` files - **NEVER** use inline `template` property
- **ALWAYS** use `templateUrl` pointing to a separate HTML file in the same directory

## Entity Framework Migrations - **CRITICAL RULE**

**IMPORTANT**: When working with Entity Framework migrations in the backend (C#/.NET):

1. **NEVER edit migration files directly** - Migration files are auto-generated and should NOT be manually edited
2. **ALWAYS create migrations using the dotnet ef command** - Use the Entity Framework CLI to generate migrations
3. **Migration Command Pattern**:
   ```powershell
   cd "C:\Users\mehdi\OneDrive\Bureau\zaRD UI ADMIN TEMPLATE\CRMRealestate-main"
   dotnet ef migrations add <MigrationName> --project "src\ImmoGest.Infrastructure" --startup-project "src\ImmoGest.Api" --context ApplicationDbContext
   ```
4. **When database schema changes are needed**:
   - ✅ First, modify the entity classes (Domain/Entities)
   - ✅ Then, modify the DTOs (Application/DTOs)
   - ✅ Then, modify the configuration classes (Infrastructure/Configuration)
   - ✅ Finally, run the migration command to generate the migration file
   - ❌ **NEVER** manually edit the generated migration file
5. **Migration file location**: `CRMRealestate-main/src/ImmoGest.Infrastructure/Migrations/`
6. **If a migration needs changes**:
   - Remove the incorrect migration using: `dotnet ef migrations remove --project "src\ImmoGest.Infrastructure" --startup-project "src\ImmoGest.Api" --context ApplicationDbContext`
   - Fix the entity/DTO/configuration files
   - Create a new migration using the command above
7. **Review migrations before applying**: Always review the generated migration file to ensure it's correct, but do NOT edit it manually
8. **Apply migrations**: Use `dotnet ef database update --project "src\ImmoGest.Infrastructure" --startup-project "src\ImmoGest.Api" --context ApplicationDbContext` to apply migrations

**Summary**: Migrations are auto-generated code. Always use the Entity Framework CLI commands to create, remove, or update migrations. Never manually edit migration files - if changes are needed, fix the source entities/DTOs/configurations and regenerate the migration.

